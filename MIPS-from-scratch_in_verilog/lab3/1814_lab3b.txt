###############################################################################################################################
Axelos Christos, AEM 1814
##############################################################################################################################
-Έστω οτι εχουμε μια δήλωση struct στην C ως εξης:
....
struct foo  {
	char a;  //1B
	bool v;  // 1B
	int c;   // 4B
	double d;  // 8B
	short e;  // 2B
	float f;  // 4B
	double g; //8B 
	char *cptr; // 4B h' 8B 
	void *vptr;  // 4B H' 8B
	int x;
};

- Ta stoixeia sthn mnhmh apo8hkevontai me thn seira pou deilwnontai sto struct
- To ka8e stoixeio apo8hkevetai se dief8ynsh ths mnhmhs pou einai POLLAPLASIA tou megethous tou stoixeiou
  p.x. double d;//mborei na apo8eutei sthn 8esh 3242343248, oxi omws kai sthn 3242343244 

############################ ΓΙΑ 32-BIT ΕΠΕΞΕΡΓΑΣΤΗ ΕΧΟΥΜΕ ############################
Α)
...sizeof(int) = 4 Bytes ...
...sizeof(int *) = 4 Bytes ...//oso dhladh to mege8os mias dief8ynshs(32bit)
...sizeof(char *) = 4 bytes ...

- Υποθετουμε οτι η στατικη Μνημη που θα χρησιμοποιησουμε ξεκιναει απο την διευθυνση 0x10010000
- Οι διευ8υνσεις που αρχιζουν οι μεταβλητεσ...
1)  char a; // 0x10010000 (οπουδηποτε)
2)  bool v; // 0x10010001 (οπουδηποτε)
	(KENO 2B)
3)  int  c; // 0x100010004 (πολλ/σιο του 4) 
4)  double d; // 0x10010008 (πολλαπλασιο του 8)
5)  short  e; // 0x10010010 (πολλαπλασιο του 2)
	(KENO 2B)
6)  float  f; // 0x10010014 (πολλαπλασιο του 4)
7)  double  g; // 0x10010018 (πολλαπλασιο του 8)
8)  char *cptr; //0x10010020(πολλαπλασιο του 4)
9)  void  *vptrl //0x10010024 (πολλαπλασιο του 4)
10) int x; // 0x10010028 (πολλαπλασιο του 4)
11)..(αρχη επομενης διευθυνσης) // 0x1001002C

##### ΕΠΟΜΕΝΩΣ ΑΠΑΙΤΟΥΝΤΑΙ 0x1001002C - 0x10010000 = 44 Bytes #####

Β)
- Τωρα αλλαζω την σειρα των στοιχειων του struct για εξοικονομηση μνημης, ωστε το struct
  να χει το μικροτερο μεγεθος

1)  double  g;    // 0x10010000 (Πολλαπλασιο του 8) 
2)  double  d;    // 0x10010008 ( -//- )
3)  void *vptr;  // 0x10010010 (Πολλαπλασιο του 4)
4)  char *cptr;   // 0x10010014 ( -//- )
5)  float  f;     // 0x10010018 ( -//- )
6)  int  c;       // 0x1001001C ( -//- )
7)  int  x;       // 0x10010020 ( -//-)
8)  short  e;     // 0x10010024 (Πολλαπλασιο του 2)
9)  bool   v;     // 0x10010026 (οπουδηποτε)
10)  char a;      // 0x10010027 (οπουδηποτε)
11)..(αρχη επομενης διευθυνσης) // 0x10010028

##### ΕΠΟΜΕΝΩΣ ΑΠΑΙΤΟΥΝΤΑΙ  0x10010028 - 0x10010000 = 40 Bytes ####


############################ ΓΙΑ 64-BIT ΕΠΕΞΕΡΓΑΣΤΗ ΕΧΟΥΜΕ ############################

...sizeof(int) = 4 Bytes ...
...sizeof(int *) = 8 Bytes ...//oso dhladh to megethos mias dief8inshs(64-bit)
...sizeof(char *) = 8 Bytes ...//oso dhladh to megethos mias dief8inshs(64-bit)
...sizeof(void *) = 8 bytes ...//oso dhladh to megethos mias dief8inshs(64-bit)

- Υποθετουμε οτι η Μνημη που 8α χρησιμοποιησουμε ξεκιναει απο την διευθυνση 0x0000000010000000

1)  char a; //  0x0000000010000000 (οπουδηποτε)...10
2)  bool v; // 0x0000000010000001 (οπουδηποτε)...9
    (KENO 2B)	
3)  int  c; // 0x0000000010000004 (πολλ/σιο του 4) ...6
4)  double d; // 0x0000000010000008 (πολλαπλασιο του 8)....4
5)  short  e; // 0x0000000010000010(πολλαπλασιο του 2)...8
    (KENO 2B)	
6)  float  f; // 0x0000000010000014 (πολλαπλασιο του 4)....5
7)  double  g; // 0x0000000010000018 (πολλαπλασιο του 8)...3
8)  char *cptr; // 0x0000000010000020 (πολλαπλασιο του 4)....2
9)  void  *vptrl // 0x0000000010000028 (πολλαπλασιο του 4)...1
10) int x; // 0x0000000010000030 (πολλαπλασιο του 4)...7
11)..(αρχη επομενης διευθυνσης) // 0x0000000010000034

###### ΕΠΟΜΕΝΩΣ ΑΠΑΙΤΟΥΝΤΑΙ 0x0000000010000034 - 0x0000000010000000 =  52 Bytes ############

- Τωρα αλλαζω την σειρα των στοιχειων του struct για εξοικονομηση μνημης, ωστε το struct
  να χει το μικροτερο μεγεθος

1)  double  g;    // 0x0000000010000000 (Πολλαπλασιο του 8) 
2)  double  d;    // 0x0000000010000008 ( -//- )
3)  void *vptr;  // 0x0000000010000010 ( -//- )
4)  char *cptr;   //0x0000000010000018 ( -//- )
5)  float  f;     // 0x0000000010000020 ( πολλαπλασιο του 4 )
6)  int  c;       // 0x0000000010000024 ( -//- )
7)  int  x;       // 0x0000000010000028 ( -//-)
8)  short  e;     // 0x000000001000002C (Πολλαπλασιο του 2)
9)  bool   v;     // 0x000000001000002E (οπουδηποτε)
10)  char a;      // 0x000000001000002F (οπουδηποτε)
11)..(αρχη επομενης διευθυνσης) // 0x0000000010000030

##### ΕΠΟΜΕΝΩΣ ΑΠΑΙΤΟΥΝΤΑΙ   0x0000000010000030 -  0x0000000010000000 = 48 Bytes  ######

###########################################################################################################################################
Γ)
- Εστω οτι εχουμε τον πινακα: struct foo[100], στην περιπτωση των 32-bit και μεγεθος του struct 44 Bytes
- Εστω οτι το foo βρισκεται στην θεση 0x10010000.
	- ΒΗΜΑ1ο: "Εντοπιζουμε τον τυπο του μεγαλυτερου στοιχειου του struct, δηλαδη double "
	- ΒΗΜΑ2ο: "Συμπληρωνουμε(offset) με n bytes, ωστε το 44bytes + n bytes να ναι πολλαπλασιο του sizeof(double)"
	- ΒΗΜΑ3ο: "Γραφουμε το επομενο struct"

ΔΗΛΑΔΗ: { &foo[0], +4bytes, &foo[1], +4bytes, ..., &foo[99], + 4 bytes}
  = 100 * 44 + 100 * 4 = 4400 + 400 = 4800, το οποιο ειναι πολλαπλασιο του sizeof(double) = 8
 	